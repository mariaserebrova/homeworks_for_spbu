Я создала граф с 4 вершинами, вес пути между каждой из вершин вводится с клавиатуры. Приступим к поиску кратчайших путей с помощью алгоритмов.

## 1) алгоритм Беллмана-Форда.
На первом шаге работы алгоритма инициализируются расстояния от исходной вершины до всех остальных вершин, как бесконечные, а расстояние до самого источника принимается равным 0.
Вторым шагом вычисляются самые короткие расстояния. Следующие шаги нужно выполнять |V|-1 раз, где |V| — число вершин в данном графе.
Произведите следующее действие для каждого ребра u-v:
Если dist[v] > dist[u] + вес ребра uv, то обновите dist[v]
dist [v] = dist [u] + вес ребра uv
На этом шаге сообщается, присутствует ли в графе цикл отрицательного веса. Для каждого ребра u-v необходимо выполнить следующее:
Если dist[v] > dist[u] + вес ребра uv, то в графе присутствует цикл отрицательного веса.


алгоритм при вводе графа исключительно с положительными весами ребер работает верно.
алгоритм допускает работу с графом, имеющим отрицательные веса ребер и так же дает верный ответ.

## 2)алгоритм Дейкстры
Алгоритм Дейкстры пошаговый. Сначала выбирается точка, от которой будут отсчитываться пути. Затем алгоритм поочередно ищет самые короткие маршруты из исходной точки в другие. Вершины, где он уже побывал, отмечает посещенными. Алгоритм использует посещенные вершины, когда рассчитывает пути для непосещенных.


алгоритм при вводе графа исключительно с положительными весами ребер работает верно.
При добавлении ребер отрицательного веса он выводит неправильный ответ, так как, сохраняя наименьшее значение в каждой вершине, предполагается, что при прохождении к следующей вершине значение может только увеличиться, а при отрицательных значениях ребер оно способно и уменьшаться. Поэтому значения будут неверными.

## 3)алгоритм Флойда-Уоршелла
позволяет найти кратчайшее расстояние между любыми двумя вершинами в графе, при этом веса ребер могут быть как положительными, так и отрицательными.

Алгоритм последовательно перебирает все такие I, через которые может лежать более короткий путь в V, чем который имеется сейчас.

## 4)алгоритм Джонсона у меня к великому сожалению не удался

## 5)алгоритм Прима

алгоритм успешно работает как с положительными, так и с отрицательными значениями весов. Данный алгоритм является лучшим из всех представленных алгоритмов.

алгоритм Прима выводит остовное дерево. из графа с n вершинами он создает граф с n вершинами и (n-1) ребрами, которые имеют минтмальный вес из всех существующих ребер. вывод моей программы - остовное дерево. первое число в строчке - номер начальной вершины, второе число в строчке - номер конечной вершины. для того, чтобы алгоритм Прима работал, граф обязательно должен быть связным.
